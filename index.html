<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Notestrator</title>
    <script>
      const { ipcRenderer } = require("electron");
    </script>
  </head>
  <body>
    <svg
      style="
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
      "
    ></svg>
    <script>
      const drawing = document.currentScript.previousElementSibling;
      window.addEventListener("mousedown", async (event) => {
        const menu = await ipcRenderer.invoke("menu");
        let handleMousemove;
        switch (menu.tool) {
          case "pen":
          case "marker":
            drawing.insertAdjacentHTML(
              "beforeend",
              `
                <path
                  d="M ${event.x} ${event.y}"
                  fill="none"
                  stroke="${menu.color}"
                  stroke-width="${
                    menu.strokeWidth * (menu.tool === "marker" ? 3 : 1)
                  }"
                  stroke-opacity="${menu.tool === "marker" ? 0.5 : 1}"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              `
            );
            const path = drawing.lastElementChild;
            const t = 0.5;
            let x0 = { x: event.x, y: event.y };
            let x1 = { x: event.x, y: event.y };
            let x2 = { x: event.x, y: event.y };
            let p1 = { x: event.x, y: event.y };
            let p2 = { x: event.x, y: event.y };
            handleMousemove = (event) => {
              // http://scaledinnovation.com/analytics/splines/aboutSplines.html
              if (event.x === x2.x && event.y === x2.y) return;
              x2 = { x: event.x, y: event.y };
              const x0_x1 = Math.sqrt((x0.x - x1.x) ** 2 + (x0.y - x1.y) ** 2);
              const x1_x2 = Math.sqrt((x1.x - x2.x) ** 2 + (x1.y - x2.y) ** 2);
              const x0_x1_x2 = x0_x1 + x1_x2;
              const ratio_x0_x1 = x0_x1 / x0_x1_x2;
              const ratio_x1_x2 = x1_x2 / x0_x1_x2;
              const w = x2.x - x0.x;
              const h = x2.y - x0.y;
              p1 = {
                x: x1.x - w * t * ratio_x0_x1,
                y: x1.y - h * t * ratio_x0_x1,
              };
              path.setAttribute(
                "d",
                `${path.getAttribute("d")} C ${p2.x} ${p2.y}, ${p1.x} ${
                  p1.y
                }, ${x1.x} ${x1.y}`
              );
              p2 = {
                x: x1.x + w * t * ratio_x1_x2,
                y: x1.y + h * t * ratio_x1_x2,
              };
              x0 = x1;
              x1 = x2;
            };
            break;
          case "eraser":
            handleMousemove = (event) => {
              const elementsToRemove = new Set();
              for (const element of drawing.querySelectorAll("*"))
                switch (element.tagName) {
                  case "polyline":
                    for (const [x, y] of element
                      .getAttribute("points")
                      .split(",")
                      .map((point) => point.trim().split(" ")))
                      if (
                        Math.sqrt((event.x - x) ** 2 + (event.y - y) ** 2) <
                        menu.strokeWidth * 5
                      )
                        elementsToRemove.add(element);
                    break;
                }

              for (const element of elementsToRemove) element.remove();
            };
            break;
        }
        window.addEventListener("mousemove", handleMousemove);
        window.addEventListener("mouseup", () => {
          window.removeEventListener("mousemove", handleMousemove);
        });
      });
    </script>
  </body>
</html>
